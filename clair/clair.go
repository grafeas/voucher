package clair

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"

	s1 "github.com/Shopify/voucher/docker/schema1"
	s2 "github.com/Shopify/voucher/docker/schema2"
	v1 "github.com/coreos/clair/api/v1"
	"github.com/docker/distribution"
	"github.com/docker/distribution/reference"
	digest "github.com/opencontainers/go-digest"
	"golang.org/x/oauth2"
)

var errNoLayers = errors.New("no layers in image, vulnerabilities have not been populated")
var errUnsupportedManifest = errors.New("manifests that are not schema version 1 or version 2 are unsupported")

// EmptyLayer generated by Dockerfile commands such as CMD or EXPOSE always has this blobSum.
// For more information, see:
// https://www.nearform.com/blog/static-analysis-of-docker-image-vulnerabilities-with-clair/
const EmptyLayer = digest.Digest("sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4")

// sendLayerToClair sends a layer from the passed repository (with the passed LayerReference).
func sendLayerToClair(config Config, tokenSrc oauth2.TokenSource, layerRef LayerReference) (err error) {
	var token *oauth2.Token

	token, err = tokenSrc.Token()
	if nil != err {
		return
	}

	layer := AddAuthorization(layerRef.GetLayer(), token)
	data := map[string]v1.Layer{
		"Layer": layer,
	}

	var buffer bytes.Buffer

	err = json.NewEncoder(&buffer).Encode(data)
	if nil != err {
		return
	}

	request, err := http.NewRequest(http.MethodPost, GetNewLayerURI(config.Hostname), &buffer)
	if nil != err {
		return
	}

	if config.UseBasicAuth() {
		config.UpdateRequest(request)
	}

	resp, err := http.DefaultClient.Do(request)
	if nil != err {
		return
	}

	defer resp.Body.Close()

	if 300 <= resp.StatusCode {
		err = fmt.Errorf("pushing layer \"%s\" to clair failed: %s", layerRef.GetURI(), getErrorFromResponse(resp))
		return
	}

	err = resp.Body.Close()

	return
}

// getLayerFromClair gets the description of the Layer with the passed digest from Clair,
// using the passed digest.
func getLayerFromClair(config Config, digest digest.Digest) (layer v1.Layer, err error) {
	request, err := http.NewRequest(http.MethodGet, GetLayerURI(config.Hostname, digest), nil)
	if nil != err {
		return
	}

	if config.UseBasicAuth() {
		config.UpdateRequest(request)
	}

	resp, err := http.DefaultClient.Do(request)
	if nil != err {
		return
	}

	defer resp.Body.Close()

	if 300 <= resp.StatusCode {
		err = fmt.Errorf("getting layer from clair failed: %s", getErrorFromResponse(resp))
		return
	}

	var layerEnv v1.LayerEnvelope

	err = json.NewDecoder(resp.Body).Decode(&layerEnv)

	if nil != layerEnv.Layer {
		layer = *layerEnv.Layer
	}

	return
}

func checkParentDigest(parent digest.Digest, config Config, vulns map[string]v1.Vulnerability) (map[string]v1.Vulnerability, error) {
	if "" != string(parent) {
		var layer v1.Layer

		var err error

		// according to the Clair API, we can just get the vulnerabilities from the last
		// layer checked by Clair. The parent digest would have been updated at the end
		// of the manifest.Layers loop.
		if layer, err = getLayerFromClair(config, parent); nil != err {
			return vulns, err
		}

		for _, feature := range layer.Features {
			for _, vul := range feature.Vulnerabilities {
				vulns[vul.Name] = vul
			}
		}
	} else {
		return vulns, errNoLayers
	}

	return vulns, nil
}

// getClairVulnerabilities gets a map[string]v1.Vulnerability from Clair, so that we can convert
// them to Voucher Vulnerabilities all at once.
func getClairVulnerabilities(manifest distribution.Manifest, config Config, tokenSrc oauth2.TokenSource, image reference.Canonical) (map[string]v1.Vulnerability, error) {
	var vulns map[string]v1.Vulnerability

	var err error

	parent := digest.Digest("")

	switch {
	case s2.IsManifest(manifest):
		m := s2.ToManifest(manifest)

		vulns, err = getSchema2Layers(m, config, tokenSrc, image, parent)
	case s1.IsManifest(manifest):
		m := s1.ToManifest(manifest)

		vulns, err = getSchema1Layers(m, config, tokenSrc, image, parent)
	default:
		return vulns, errUnsupportedManifest
	}

	return vulns, err
}
