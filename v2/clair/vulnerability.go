package clair

import (
	v1 "github.com/coreos/clair/api/v1"
	clairdb "github.com/coreos/clair/database"

	voucher "github.com/grafeas/voucher/v2"
)

// getSeverity converts a Clair serverity into a Voucher serverity.
func getSeverity(severity string) voucher.Severity {
	switch clairdb.Severity(severity) {
	case clairdb.NegligibleSeverity:
		return voucher.NegligibleSeverity
	case clairdb.LowSeverity:
		return voucher.LowSeverity
	case clairdb.MediumSeverity:
		return voucher.MediumSeverity
	case clairdb.HighSeverity:
		return voucher.HighSeverity
	case clairdb.CriticalSeverity:
		return voucher.CriticalSeverity
	}
	return voucher.UnknownSeverity
}

// vulnerabilityToVoucherVulnerability converts a Clair Vulnerability to
// a Voucher Vulnerability.
func vulnerabilityToVoucherVulnerability(clairVuln v1.Vulnerability) voucher.Vulnerability {
	severity := getSeverity(clairVuln.Severity)

	return voucher.Vulnerability{
		Name:        clairVuln.Name,
		Description: clairVuln.Description,
		FixedBy:     clairVuln.FixedBy,
		Severity:    severity,
	}
}

// convertToVoucherVulnerabilities convert a list of clair vulnerabilities to
// voucher vulnerabilities
func convertToVoucherVulnerabilities(clairVulns map[string]v1.Vulnerability, failOnSeverity voucher.Severity) []voucher.Vulnerability {
	vulns := make([]voucher.Vulnerability, 0, len(clairVulns))
	for _, clairVuln := range clairVulns {
		if "" == clairVuln.Name {
			continue
		}
		vuln := vulnerabilityToVoucherVulnerability(clairVuln)
		if voucher.ShouldIncludeVulnerability(vuln, failOnSeverity) {
			vulns = append(vulns, vuln)
		}
	}
	return vulns
}
